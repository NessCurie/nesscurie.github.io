<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>RecyclerView总结与多功能便捷Adapter的封装 | Möbius Strip World</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RecyclerView总结与多功能便捷Adapter的封装</h1><a id="logo" href="/.">Möbius Strip World</a><p class="description">What will your verse be ？</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RecyclerView总结与多功能便捷Adapter的封装</h1><div class="post-meta">Mar 13, 2017<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><a class="disqus-comment-count" href="/2017/03/13/RecyclerView%E6%80%BB%E7%BB%93%E4%B8%8EAdapter%E7%9A%84%E5%B0%81%E8%A3%85/#vcomment"><span class="valine-comment-count" data-xid="/2017/03/13/RecyclerView%E6%80%BB%E7%BB%93%E4%B8%8EAdapter%E7%9A%84%E5%B0%81%E8%A3%85/"></span><span> Comment</span></a><div class="post-content"><p>虽然RecyclerView在5.0时代就已经出来了,不过因为各方面原因,以及ListView以前用的很多,各种特殊处理也更熟悉,所以当出现非表格形式的列表级控件需求的时候第一时间想到的是listview而不是RecyclerView,所以造成了RecyclerView虽然出了不少时间了,但是和ListView的熟练度相比还是差很多,这次主要就是总结记录一下RecyclerView的基础用法并对其Adapter进行封装,方便更简单的进行各种功能的实现.</p>
<p>封装的项目在Git的<a href="https://github.com/NessCurie/RecyclerViewUtils" target="_blank" rel="noopener">RecyclerViewUtils</a>,项目具体内容可以参照文章下半部分或项目中的README</p>
<h6 id="ps-虽然RecyclerView在5-0才正式推出-不过在4-4的launcher3的代码中就已经出现了RecyclerView的身影-说明Google很早就开始编写了-只是因为没有完善或其他什么原因后续才推出"><a href="#ps-虽然RecyclerView在5-0才正式推出-不过在4-4的launcher3的代码中就已经出现了RecyclerView的身影-说明Google很早就开始编写了-只是因为没有完善或其他什么原因后续才推出" class="headerlink" title="ps:虽然RecyclerView在5.0才正式推出,不过在4.4的launcher3的代码中就已经出现了RecyclerView的身影,说明Google很早就开始编写了,只是因为没有完善或其他什么原因后续才推出."></a>ps:虽然RecyclerView在5.0才正式推出,不过在4.4的launcher3的代码中就已经出现了RecyclerView的身影,说明Google很早就开始编写了,只是因为没有完善或其他什么原因后续才推出.</h6><h2 id="RecyclerView的一般使用"><a href="#RecyclerView的一般使用" class="headerlink" title="RecyclerView的一般使用"></a>RecyclerView的一般使用</h2><h3 id="1-设置LayoutManager"><a href="#1-设置LayoutManager" class="headerlink" title="1. 设置LayoutManager"></a>1. 设置LayoutManager</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.setLayoutManager(LayoutManager manager);</span><br></pre></td></tr></table></figure>

<p>RecyclerView支持三种LayoutManager: </p>
<h4 id="LinearLayoutManager-nbsp-nbsp-nbsp-nbsp-和ListView类似-不过可以通过传入不同的参数控制方向"><a href="#LinearLayoutManager-nbsp-nbsp-nbsp-nbsp-和ListView类似-不过可以通过传入不同的参数控制方向" class="headerlink" title="LinearLayoutManager&nbsp;&nbsp;&nbsp;&nbsp;和ListView类似,不过可以通过传入不同的参数控制方向:"></a>LinearLayoutManager&nbsp;&nbsp;&nbsp;&nbsp;和ListView类似,不过可以通过传入不同的参数控制方向:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinearLayoutManager.VERTICAL      纵向</span><br><span class="line">LinearLayoutManager.HORIZONTAL    横向</span><br></pre></td></tr></table></figure>

<h4 id="GridLayoutManager-nbsp-nbsp-nbsp-nbsp-和GridView类似-也可以通过传入不同的参数控制方向"><a href="#GridLayoutManager-nbsp-nbsp-nbsp-nbsp-和GridView类似-也可以通过传入不同的参数控制方向" class="headerlink" title="GridLayoutManager&nbsp;&nbsp;&nbsp;&nbsp;和GridView类似,也可以通过传入不同的参数控制方向:"></a>GridLayoutManager&nbsp;&nbsp;&nbsp;&nbsp;和GridView类似,也可以通过传入不同的参数控制方向:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GridLayoutManager.VERTICAL        纵向</span><br><span class="line">GridLayoutManager.HORIZONTAL      横向</span><br></pre></td></tr></table></figure>

<h4 id="StaggeredGridLayoutManager-nbsp-nbsp-nbsp-nbsp-会自动根据内容大小对高度或宽度进行适应的GridLayout-可以简单的完成瀑布流效果-也可以通过不同的参数控制方向"><a href="#StaggeredGridLayoutManager-nbsp-nbsp-nbsp-nbsp-会自动根据内容大小对高度或宽度进行适应的GridLayout-可以简单的完成瀑布流效果-也可以通过不同的参数控制方向" class="headerlink" title="StaggeredGridLayoutManager&nbsp;&nbsp;&nbsp;&nbsp;会自动根据内容大小对高度或宽度进行适应的GridLayout,可以简单的完成瀑布流效果,也可以通过不同的参数控制方向:"></a>StaggeredGridLayoutManager&nbsp;&nbsp;&nbsp;&nbsp;会自动根据内容大小对高度或宽度进行适应的GridLayout,可以简单的完成瀑布流效果,也可以通过不同的参数控制方向:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StaggeredGridLayoutManager.HORIZONTAL  纵向</span><br><span class="line">StaggeredGridLayoutManager.VERTICAL    横向</span><br></pre></td></tr></table></figure>

<p>1.虽然上面三个LayoutManager控制方向的参数都看起来名称不相同,不过其实都是相同的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OrientationHelper.HORIZONTAL</span><br><span class="line">OrientationHelper.VERTICAL</span><br></pre></td></tr></table></figure>

<p>2.如果使用最简单的构造方法,默认方向为VERTICAL</p>
<p>3.如果传入了方向,创建LinearLayoutManager和GridLayoutManager的时候需要还有一个boolean变量reverseLayout需要传入,表示是否从最后一个开始布局,一般这个值是传入false的.</p>
<p>实际效果是传入adapter集合的数据会从列表的最后面开始往前布局,列表初始显示的时候也会显示在最后一个.</p>
<p>StaggeredGridLayoutManager并没有提供该方式,应该是由于StaggeredGridLayoutManager是另外实现的.</p>
<pre><code>LinearLayoutManager继承于LayoutManager,GridLayoutManager继承于LinearLayoutManager

GridLayoutManager相当于是对LinearLayoutManager的扩展

但StaggeredGridLayoutManager是重新继承于LayoutManager,不是对GridLayoutManager进行拓展.</code></pre><p>4.创建GridLayoutManager和StaggeredGridLayoutManager的对象的时候,需要传入一个spanCount的参数,如果传入的方向是横向就代表多少横行,传入的方向是竖向,代表多少竖列.</br></p>
<h3 id="2-添加分割线"><a href="#2-添加分割线" class="headerlink" title="2. 添加分割线"></a>2. 添加分割线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.addItemDecoration(RecyclerView.ItemDecoration decor)</span><br></pre></td></tr></table></figure>

<p>此处需要传入一个分割线<code>ItemDecoration</code>抽象类的实现类的对象.<br>v7包中有一个简单的实现类<code>DividerItemDecoration</code>不过这个实现类只支持传入横向或竖向的的分割线不能同时横竖都显示.</p>
<p>DividerItemDecoration的分割线样式是使用主题中android:listDivider属性指定的样式,如果想更改样式可以在styles.xml中对使用的主题重写该属性:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:listDivider"</span>&gt;</span>@drawable/divider_bg<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用自己drawable下的文件作为分割线的样式,可以使用shape自己绘制对应的分割线,具体的查看shape的用法,下面是两个简单的例子:</p>
<p>使用对应颜色值和宽高作为分割线:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:shape</span>=<span class="string">"rectangle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"颜色值"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用渐变的颜色值作为分割线:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:shape</span>=<span class="string">"rectangle"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">gradient</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:centerColor</span>=<span class="string">"颜色值1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:endColor</span>=<span class="string">"颜色值2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:startColor</span>=<span class="string">"颜色值3"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:type</span>=<span class="string">"linear"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"2dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"2dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="如果需要GridLayoutManager横竖都显示分割线-需要自己编写一个类继承ItemDecoration-在onDraw-方法中进行实现"><a href="#如果需要GridLayoutManager横竖都显示分割线-需要自己编写一个类继承ItemDecoration-在onDraw-方法中进行实现" class="headerlink" title="如果需要GridLayoutManager横竖都显示分割线,需要自己编写一个类继承ItemDecoration,在onDraw()方法中进行实现."></a>如果需要GridLayoutManager横竖都显示分割线,需要自己编写一个类继承ItemDecoration,在onDraw()方法中进行实现.</h4><p>在onDraw使用参数中RecyclerView的对象获取LayoutManager,然后判断是哪种布局的哪个方向:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView.LayoutManager layoutManager = parent.getLayoutManager();</span><br><span class="line"><span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> GridLayoutManager) &#123;</span><br><span class="line">    orientation = ((GridLayoutManager) layoutManager).getOrientation();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> StaggeredGridLayoutManager) &#123;</span><br><span class="line">    orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    orientation = ((LinearLayoutManager) layoutManager).getOrientation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确定方向后即可使用方法中的Canvas绘制分割线,中间可以使用recyclerView的对象调用getChildCount()获取子布局数量,遍历所有子布局.通过获取子布局的坐标确定分割线的坐标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在所有的子布局的底部绘制分割线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawHorizontal</span><span class="params">(Canvas c, RecyclerView parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line">    <span class="keyword">int</span> spanCount = getSpanCount(parent);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (orientation == OrientationHelper.VERTICAL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= childCount - spanCount) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        View child = parent.getChildAt(i);</span><br><span class="line">        RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">int</span> left = child.getLeft() - params.leftMargin;</span><br><span class="line">        <span class="keyword">int</span> right = child.getRight() + params.rightMargin + drawable.getIntrinsicWidth();</span><br><span class="line">        <span class="keyword">int</span> top = child.getBottom() + params.bottomMargin;</span><br><span class="line">        <span class="keyword">int</span> bottom = top + drawable.getIntrinsicHeight();</span><br><span class="line">        drawable.setBounds(left, top, right, bottom);</span><br><span class="line">        drawable.draw(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在所有的子布局的右边绘制分割线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawVertical</span><span class="params">(Canvas c, RecyclerView parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childCount = parent.getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        View child = parent.getChildAt(i);</span><br><span class="line">        RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">int</span> top = child.getTop() - params.topMargin;</span><br><span class="line">        <span class="keyword">int</span> bottom = child.getBottom() + params.bottomMargin;</span><br><span class="line">        <span class="keyword">int</span> left = child.getRight() + params.rightMargin;</span><br><span class="line">        <span class="keyword">int</span> right = left + drawable.getIntrinsicWidth();</span><br><span class="line">        drawable.setBounds(left, top, right, bottom);</span><br><span class="line">        drawable.draw(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取列数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSpanCount</span><span class="params">(RecyclerView parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> spanCount;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = parent.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> GridLayoutManager) &#123;</span><br><span class="line">        spanCount = ((GridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> StaggeredGridLayoutManager) &#123;</span><br><span class="line">        spanCount = ((StaggeredGridLayoutManager) layoutManager).getSpanCount();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spanCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> spanCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对ItemDecoration的简单实现包含在<a href="https://github.com/NessCurie/RecyclerViewUtils/blob/master/library/src/main/java/org/nesscurie/recyclerviewutils/SimpleDecoration.java" target="_blank" rel="noopener">RecyclerViewUtils/SimpleDecoration</a>中</p>
<h4 id="给item设置状态选择器后分割线消失的情况"><a href="#给item设置状态选择器后分割线消失的情况" class="headerlink" title="给item设置状态选择器后分割线消失的情况"></a>给item设置状态选择器后分割线消失的情况</h4><p>如果需要给item设置状态选择器,这时就只能给item的对象设置background为状态选择器的drawable了,但是上面的分割线实际上是绘制在RecyclerView上的,并不是绘制在item上,所以item的背景肯定会挡住分割线.</p>
<p>只是普通的状态选择器时,可以将默认的颜色设置给recyclerView,然后item的状态选择器的默认颜色设置为透明.</p>
<p>这种方式对5.0以上的水波纹效果的状态选择器不适用,当水波纹状态选择器里面的颜色有透明时就没有水波纹效果了,只能给item的布局中的控件设置margin做出类似分割线的效果或在item中添加view作为分割线.</p>
<p>总的来说就是分割线绘制在recyclerView不在item的view上,item默认为透明的,当设置颜色之后就会挡住分割线,采用上面一些方式避免挡住分割线或在item上显示分割线等多种方法都可以解决.</p>
<h3 id="3-添加Item添加和移除的动画"><a href="#3-添加Item添加和移除的动画" class="headerlink" title="3. 添加Item添加和移除的动画"></a>3. 添加Item添加和移除的动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.setItemAnimator(ItemAnimator animator);</span><br></pre></td></tr></table></figure>

<p>这里需要传入RecyclerView.ItemAnimator的实现类,需要自己实现可以继承其简单实现类SimpleItemAnimator对其中的方法进行编写.</p>
<p>v7包中提供了简单的实现DefaultItemAnimator.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recyclerView.setItemAnimator(new DefaultItemAnimator());</span><br></pre></td></tr></table></figure>

<p>另外对于移除和添加时刷新界面不再是像ListView调用<code>notifyDataSetChanged()</code>即可,RecyclerView添加时需要调用<code>notifyItemInserted(int position)</code>,移除item的时候调用<code>notifyItemRemoved(int position)</code>,另外除了添加和移除,还有item改变的刷新方法:<code>notifyItemChanged(int position)</code></p>
<p>对于动画的实现并没有深究,更多的内容可以在Git上面找到,比如<a href="https://github.com/gabrielemariotti/RecyclerViewItemAnimators" target="_blank" rel="noopener">RecyclerViewItemAnimators</a>,不过运行了之后发现动画效果并不是很明显.</p>
<h3 id="4-实现RecyclerView-Adapter和RecyclerView-ViewHolder"><a href="#4-实现RecyclerView-Adapter和RecyclerView-ViewHolder" class="headerlink" title="4. 实现RecyclerView.Adapter和RecyclerView.ViewHolder"></a>4. 实现RecyclerView.Adapter和RecyclerView.ViewHolder</h3><p>RecyclerView的adapter和viewHolder已经对item的复用进行了实现,只需要进行继承,在对应的方法中进行对应的操作即可.</p>
<h4 id="1-实现ViewHolder"><a href="#1-实现ViewHolder" class="headerlink" title="1. 实现ViewHolder"></a>1. 实现ViewHolder</h4><p>继承RecyclerViewHolder后,必须要重写其有参构造,其参数View itemView就是item的View对象,这里需要从其中找到所有需要的对象,并将找到的对象提升为成员变量方便直接使用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TextView tvItem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewHolder</span><span class="params">(View itemView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(itemView);</span><br><span class="line">        tvItem = (TextView) itemView.findViewById(R.id.tv_item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-实现Adapter"><a href="#2-实现Adapter" class="headerlink" title="2. 实现Adapter"></a>2. 实现Adapter</h4><p>继承RecyclerView.Adapter时,需要传入一个泛型,这个泛型就是实现的ViewHolder,需要重写3个方法:</p>
<p><code>getItemCount()</code>需要返回item数量,一般就是传入集合是size</p>
<p><code>VH onCreateViewHolder(ViewGroup parent, int viewType)</code>创建ViewHolder的对象并返回</p>
<p><code>onBindViewHolder(final MyViewHolder holder, final int position)</code>绑定数据</p>
<p>具体实现例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">MyViewHolder</span>&gt;  </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyViewHolder(View.inflate(MainActivity.<span class="keyword">this</span>, R.layout.item_recycler, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> MyViewHolder holder, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        holder.tvItem.setText(list.get(position));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现ViewHolder和Adapter之后设置给RecyclerView就可以显示数据"><a href="#实现ViewHolder和Adapter之后设置给RecyclerView就可以显示数据" class="headerlink" title="实现ViewHolder和Adapter之后设置给RecyclerView就可以显示数据"></a>实现ViewHolder和Adapter之后设置给RecyclerView就可以显示数据</h4><p><code>recyclerView.setAdapter(myAdapter);</code></p>
<h3 id="5-RecyclerView并没有提供设置Item的点击事件或长按事件-需要自己在Adapter中onBindViewHolder-方法中进行设置"><a href="#5-RecyclerView并没有提供设置Item的点击事件或长按事件-需要自己在Adapter中onBindViewHolder-方法中进行设置" class="headerlink" title="5. RecyclerView并没有提供设置Item的点击事件或长按事件,需要自己在Adapter中onBindViewHolder()方法中进行设置."></a>5. RecyclerView并没有提供设置Item的点击事件或长按事件,需要自己在Adapter中onBindViewHolder()方法中进行设置.</h3><p>可以在onBindViewHolder(VH holder, int position);从holder获取整个item的对象,对其设置点击或长按事件.</p>
<p>也可以在Adapter中添加两个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnItemClickListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnItemLongClickListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">onItemLongClick</span><span class="params">(View view, RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> OnItemClickListener onItemClickListener;</span><br><span class="line"><span class="keyword">private</span> OnItemLongClickListener onItemLongClickListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置长按事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onItemLongClickListener imp&#123;<span class="doctag">@link</span> OnItemLongClickListener&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnItemLongClickListener</span><span class="params">(OnItemLongClickListener onItemLongClickListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.onItemLongClickListener = onItemLongClickListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置点击事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onItemClickListener imp&#123;<span class="doctag">@link</span> OnItemClickListener&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnItemClickListener</span><span class="params">(OnItemClickListener onItemClickListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.onItemClickListener = onItemClickListener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在onBindViewHolder中,设置item的view的点击和长按事件为当onItemClickListener和onItemLongClickListener不为null时,调用接口中的方法</p>
<p>可以参考<a href="https://github.com/NessCurie/RecyclerViewUtils/blob/master/library/src/main/java/org/nesscurie/recyclerviewutils/BaseAdapter.java" target="_blank" rel="noopener">RecyclerViewUtils/BaseAdapter</a>中的BaseAdapter的部分代码.</p>
<h3 id="6-RecyclerView的下拉刷新和加载更多"><a href="#6-RecyclerView的下拉刷新和加载更多" class="headerlink" title="6. RecyclerView的下拉刷新和加载更多"></a>6. RecyclerView的下拉刷新和加载更多</h3><h4 id="RecyclerView的下拉刷新有很多实现方式-在网上可以找到很多实现的方式-Google也提供了官方的android-support-v4-widget-SwipeRefreshLayout-在xml文件中对ListView或RecyclerView进行包裹后即可获取在列表顶部时下拉事件-显示刷新状态的控件"><a href="#RecyclerView的下拉刷新有很多实现方式-在网上可以找到很多实现的方式-Google也提供了官方的android-support-v4-widget-SwipeRefreshLayout-在xml文件中对ListView或RecyclerView进行包裹后即可获取在列表顶部时下拉事件-显示刷新状态的控件" class="headerlink" title="RecyclerView的下拉刷新有很多实现方式,在网上可以找到很多实现的方式,Google也提供了官方的android.support.v4.widget.SwipeRefreshLayout,在xml文件中对ListView或RecyclerView进行包裹后即可获取在列表顶部时下拉事件,显示刷新状态的控件."></a>RecyclerView的下拉刷新有很多实现方式,在网上可以找到很多实现的方式,Google也提供了官方的android.support.v4.widget.SwipeRefreshLayout,在xml文件中对ListView或RecyclerView进行包裹后即可获取在列表顶部时下拉事件,显示刷新状态的控件.</h4><p>SwipeRefreshLayout提供了一些方法:</p>
<p>设置刷新控件的背景颜色:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">refreshLayout.setProgressBackgroundColorSchemeResource(int colorRes);</span><br><span class="line">refreshLayout.setProgressBackgroundColorSchemeColor(int color);</span><br></pre></td></tr></table></figure>

<p>设置刷新进度条的颜色,可以传入多个颜色值,会依次显示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refreshLayout.setColorSchemeResources();</span><br></pre></td></tr></table></figure>

<p>设置当前是否显示刷新控件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRefreshing(boolean refreshing);</span><br></pre></td></tr></table></figure>

<h4 id="RecyclerView加载更多网上也有很多实现方式-可以自行寻找需求需要的样式-在这里提供一个Git上对SwipeRefreshLayout进行修改-不仅支持下拉刷新也支持上拉加载更多-SwipyRefreshLayout"><a href="#RecyclerView加载更多网上也有很多实现方式-可以自行寻找需求需要的样式-在这里提供一个Git上对SwipeRefreshLayout进行修改-不仅支持下拉刷新也支持上拉加载更多-SwipyRefreshLayout" class="headerlink" title="RecyclerView加载更多网上也有很多实现方式,可以自行寻找需求需要的样式,在这里提供一个Git上对SwipeRefreshLayout进行修改,不仅支持下拉刷新也支持上拉加载更多.SwipyRefreshLayout"></a>RecyclerView加载更多网上也有很多实现方式,可以自行寻找需求需要的样式,在这里提供一个Git上对SwipeRefreshLayout进行修改,不仅支持下拉刷新也支持上拉加载更多.<a href="https://github.com/OrangeGangsters/SwipyRefreshLayout" target="_blank" rel="noopener">SwipyRefreshLayout</a></h4><p>为了和条目拖动兼容和方便使用进行了少量修改,复制到了<a href="https://github.com/NessCurie/RecyclerViewUtils/blob/master/library/src/main/java/org/nesscurie/recyclerviewutils/SwipyRefreshLayout.java" target="_blank" rel="noopener">RecyclerViewUtils/SwipyRefreshLayout</a>中.</p>
<p>可以在xml中使用属性<code>app:refresh_mode=&quot;top/bottom/both&quot;</code>表示支持哪些模式</p>
<p>或者在代码中调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRefreshMode(SwipyRefreshLayout.TOP|SwipyRefreshLayout.BOTTOM |SwipyRefreshLayout.BOTH);</span><br></pre></td></tr></table></figure>

<p>其他使用方式与SwipeRefreshLayout基本一样.</p>
<h3 id="7-RecyclerView的条目拖动和侧拉删除"><a href="#7-RecyclerView的条目拖动和侧拉删除" class="headerlink" title="7. RecyclerView的条目拖动和侧拉删除"></a>7. RecyclerView的条目拖动和侧拉删除</h3><p>网上也有很多其他实现方式,这里提供一个Google提供的ItemTouchHelper的用法,7.0系统设置中语音设置那里的item的上下拖动就是使用该类实现的.</p>
<p>创建ItemTouchHelper对象需要传入一个ItemTouchHelper.Callback子类对象,所以首先需要编写一个ItemTouchHelper.Callback的继承类</p>
<h4 id="1-在getMovementFlags-RecyclerView-recyclerView-RecyclerView-ViewHolder-viewHolder-方法中指定可以支持的拖放和滑动的方向-调用makeMovementFlags-int-dragFlags-int-swipeFlags-来返回"><a href="#1-在getMovementFlags-RecyclerView-recyclerView-RecyclerView-ViewHolder-viewHolder-方法中指定可以支持的拖放和滑动的方向-调用makeMovementFlags-int-dragFlags-int-swipeFlags-来返回" class="headerlink" title="1. 在getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)方法中指定可以支持的拖放和滑动的方向,调用makeMovementFlags(int dragFlags, int swipeFlags)来返回"></a>1. 在getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)方法中指定可以支持的拖放和滑动的方向,调用makeMovementFlags(int dragFlags, int swipeFlags)来返回</h4><p>在是表格布局的时候只支持上下左右的条目拖动不支持侧拉删除,在LinearLayoutManager的情况下左右滑动时为侧拉删除和上下的时候为条目拖动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 指定可以支持的拖放和滑动的方向</span></span><br><span class="line"><span class="comment"> * makeMovementFlags(int dragFlags, int swipeFlags)来构造返回的flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> GridLayoutManager</span><br><span class="line">            || layoutManager <span class="keyword">instanceof</span> StaggeredGridLayoutManager) &#123;</span><br><span class="line">        <span class="keyword">int</span> dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN |</span><br><span class="line">                ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</span><br><span class="line">        <span class="keyword">int</span> swipeFlags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> makeMovementFlags(dragFlags, swipeFlags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;</span><br><span class="line">        <span class="keyword">int</span> swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END;</span><br><span class="line">        <span class="keyword">return</span> makeMovementFlags(dragFlags, swipeFlags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-在移动条目的时候会调用onMove方法-在侧拉时会调用onSwiped方法-所以在此方法中对数据进行操作"><a href="#2-在移动条目的时候会调用onMove方法-在侧拉时会调用onSwiped方法-所以在此方法中对数据进行操作" class="headerlink" title="2. 在移动条目的时候会调用onMove方法,在侧拉时会调用onSwiped方法,所以在此方法中对数据进行操作."></a>2. 在移动条目的时候会调用onMove方法,在侧拉时会调用onSwiped方法,所以在此方法中对数据进行操作.</h4><p>如果是内部类的形式可以直接调用外部的adapter的对象,不是内部类的时候需要将adapter通过构造方法传入.</p>
<p>在onMove方法中可以通过参数获取到起始位置的position和目标位置的position</p>
<pre><code>获取初始位置 viewHolder.getAdapterPosition()
    获取目标位置 target.getAdapterPosition()</code></pre><p>拿到position后交换集合中的数据并刷新界面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.swap(list, fromPosition, toPosition);</span><br><span class="line">adapter.notifyItemMoved(fromPosition, toPosition);</span><br></pre></td></tr></table></figure>

<p>在onSwiped中也是同样获取到侧拉条目的position</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewHolder.getAdapterPosition()</span><br></pre></td></tr></table></figure>

<p>拿到position后移除集合中的数据并刷新界面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.remove(position);</span><br><span class="line">notifyItemRemoved(position);</span><br></pre></td></tr></table></figure>

<p>另外也可以采用回调的形式,只需要把索引传入对应的方法即可<br>具体可以查看<a href="https://github.com/NessCurie/RecyclerViewUtils/tree/master/library/src/main/java/org/nesscurie/recyclerviewutils" target="_blank" rel="noopener">RecyclerViewUtils</a>中的<a href="https://github.com/NessCurie/RecyclerViewUtils/blob/master/library/src/main/java/org/nesscurie/recyclerviewutils/ItemTouchDataCallBack.java" target="_blank" rel="noopener">ItemTouchDataCallBack</a>和<a href="https://github.com/NessCurie/RecyclerViewUtils/blob/master/library/src/main/java/org/nesscurie/recyclerviewutils/SimpleItemTouchCallBack.java" target="_blank" rel="noopener">SimpleItemTouchCallBack</a>以及<a href="https://github.com/NessCurie/RecyclerViewUtils/blob/master/library/src/main/java/org/nesscurie/recyclerviewutils/BaseAdapter.java" target="_blank" rel="noopener">BaseAdapter</a></p>
<h4 id="另外在ItemTouchHelper-Callback继承类中还有一些方法"><a href="#另外在ItemTouchHelper-Callback继承类中还有一些方法" class="headerlink" title="另外在ItemTouchHelper.Callback继承类中还有一些方法:"></a>另外在ItemTouchHelper.Callback继承类中还有一些方法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">决定是否支持长按拖动      isLongPressDragEnabled();</span><br><span class="line">决定是否支持侧拉删除:     isItemViewSwipeEnabled();</span><br><span class="line">拖动或侧拉效果开始:       onSelectedChanged();</span><br><span class="line">拖动或侧拉效果完成:       clearView();</span><br><span class="line">决定产生什么动画效果:     onChildDraw();</span><br></pre></td></tr></table></figure>

<p>上面的方法都可以进行重写后添加逻辑或进行更改,重写后如果不是完全对逻辑进行了修改需要保留super语句.</p>
<h4 id="如果想通过触摸某个控件触发条目的拖动"><a href="#如果想通过触摸某个控件触发条目的拖动" class="headerlink" title="如果想通过触摸某个控件触发条目的拖动"></a>如果想通过触摸某个控件触发条目的拖动</h4><p>只需要对对应的控件设置setOnTouchListener(),当事件为点击时调用ItemTouchHelper的startDrag(ViewHolder viewHolder)开启拖动:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">view.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MotionEventCompat.getActionMasked(event) == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            helper.startDrag(MViewHolder.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="创建完ItemTouchHelper后最后需要与recyclerView关联绑定"><a href="#创建完ItemTouchHelper后最后需要与recyclerView关联绑定" class="headerlink" title="创建完ItemTouchHelper后最后需要与recyclerView关联绑定:"></a>创建完ItemTouchHelper后最后需要与recyclerView关联绑定:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchHelper.attachToRecyclerView(recyclerView);</span><br></pre></td></tr></table></figure>

<h3 id="8-多类型的item的显示"><a href="#8-多类型的item的显示" class="headerlink" title="8. 多类型的item的显示"></a>8. 多类型的item的显示</h3><p>在RecyclerView.Adapter中getItemViewType(int position)方法返回的是表示item的类型的type.<br>对item进行复用时会根据getItemViewType(int position)返回的判断是否是对应的item才进行复用.</p>
<p>当要实现多类型item的时候需要自行对type进行管理,使用集合中的数据判断是否是对应的type然后决定使用哪种对应的item的布局,<br>在onCreateViewHolder(ViewGroup parent, int viewType)方法中,也可以看到传来的参数有item的type类型.</p>
<h4 id="1-使用接口IType表示每种item的Type的实现-在接口中提供下面的方法"><a href="#1-使用接口IType表示每种item的Type的实现-在接口中提供下面的方法" class="headerlink" title="1. 使用接口IType表示每种item的Type的实现,在接口中提供下面的方法:"></a>1. 使用接口IType<T>表示每种item的Type的实现,在接口中提供下面的方法:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取对应的item的layout的id的方法:  <span class="function"><span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span></span>;</span><br><span class="line">判断是否是此type类型的item:        <span class="function"><span class="keyword">boolean</span> <span class="title">isThisTypeItem</span><span class="params">(T item, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">为item设置数据的方式:              <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(MViewHolder holder, T t, <span class="keyword">int</span> position)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-将所有的type在adapter中通过集合来管理-提供添加type的方法-然后重写getItemViewType-方法"><a href="#2-将所有的type在adapter中通过集合来管理-提供添加type的方法-然后重写getItemViewType-方法" class="headerlink" title="2. 将所有的type在adapter中通过集合来管理,提供添加type的方法. 然后重写getItemViewType()方法"></a>2. 将所有的type在adapter中通过集合来管理,提供添加type的方法. 然后重写getItemViewType()方法</h4><p>对集合进行遍历,根据索引获取集合中对应的数据,使用数据判断是否是此type类型的item</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SparseArrayCompat&lt;IType&lt;T&gt;&gt; types = <span class="keyword">new</span> SparseArrayCompat&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加item的type</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type item的type &#123;<span class="doctag">@link</span> IType&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addType</span><span class="params">(IType&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">        types.put(types.size(), type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMoreOneType()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (types.valueAt(i).isThisTypeItem(list.get(position), position)) &#123;</span><br><span class="line">                <span class="keyword">return</span> types.keyAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * item是否是多type类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMoreOneType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> types.size() &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-在创建viewHolder的方法onCreateViewHolder-ViewGroup-parent-int-viewType-中根据viewType获取集合中对应的IType对象-获取对应的layout的id创建ViewHolder对象"><a href="#3-在创建viewHolder的方法onCreateViewHolder-ViewGroup-parent-int-viewType-中根据viewType获取集合中对应的IType对象-获取对应的layout的id创建ViewHolder对象" class="headerlink" title="3. 在创建viewHolder的方法onCreateViewHolder(ViewGroup parent, int viewType)中根据viewType获取集合中对应的IType对象,获取对应的layout的id创建ViewHolder对象."></a>3. 在创建viewHolder的方法onCreateViewHolder(ViewGroup parent, int viewType)中根据viewType获取集合中对应的IType对象,获取对应的layout的id创建ViewHolder对象.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建viewHolder对象,会使用&#123;<span class="doctag">@link</span> IType#getLayoutId()&#125;返回的Layout创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">    MViewHolder holder = MViewHolder.createHolder(context, types.get(viewType).getLayoutId(), helper);</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-在绑定数据的方法中遍历type的集合-根据position获取集合中对应的数据-根据数据判断是否是对应的type-是则调用IType中的设置数据的方式进行数据赋值"><a href="#4-在绑定数据的方法中遍历type的集合-根据position获取集合中对应的数据-根据数据判断是否是对应的type-是则调用IType中的设置数据的方式进行数据赋值" class="headerlink" title="4. 在绑定数据的方法中遍历type的集合,根据position获取集合中对应的数据,根据数据判断是否是对应的type,是则调用IType中的设置数据的方式进行数据赋值."></a>4. 在绑定数据的方法中遍历type的集合,根据position获取集合中对应的数据,根据数据判断是否是对应的type,是则调用IType中的设置数据的方式进行数据赋值.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定数据</span></span><br><span class="line"><span class="comment"> * 会根据&#123;<span class="doctag">@link</span> IType&#125;中的 &#123;<span class="doctag">@link</span> IType#isThisTypeItem(Object, int)&#125;判断是否是对应的item</span></span><br><span class="line"><span class="comment"> * 使用&#123;<span class="doctag">@link</span> IType&#125;中的&#123;<span class="doctag">@link</span> IType#setData(MViewHolder, Object, int)&#125;为item设置数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(MViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    T t = list.get(position);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.size(); i++) &#123;</span><br><span class="line">        IType&lt;T&gt; type = types.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (type.isThisTypeItem(t, position)) &#123;</span><br><span class="line">            type.setData(holder, t, position);</span><br><span class="line">            setListener(holder, types.indexOfValue(type), position);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这样就完成了多类型item的adapter-会自动根据传入adapter的集合中每条数据的区别显示对应的item"><a href="#这样就完成了多类型item的adapter-会自动根据传入adapter的集合中每条数据的区别显示对应的item" class="headerlink" title="这样就完成了多类型item的adapter,会自动根据传入adapter的集合中每条数据的区别显示对应的item."></a>这样就完成了多类型item的adapter,会自动根据传入adapter的集合中每条数据的区别显示对应的item.</h4><p>具体内容可以查看<a href="https://github.com/NessCurie/RecyclerViewUtils/blob/master/library/src/main/java/org/nesscurie/recyclerviewutils/IType.java" target="_blank" rel="noopener">IType</a>,&nbsp;<a href="https://github.com/NessCurie/RecyclerViewUtils/blob/master/library/src/main/java/org/nesscurie/recyclerviewutils/MViewHolder.java" target="_blank" rel="noopener">MViewHolder</a>;&nbsp;<a href="https://github.com/NessCurie/RecyclerViewUtils/blob/master/library/src/main/java/org/nesscurie/recyclerviewutils/BaseAdapter.java" target="_blank" rel="noopener">BaseAdapter</a></p>
<h2 id="对上述内容的综合封装"><a href="#对上述内容的综合封装" class="headerlink" title="对上述内容的综合封装"></a>对上述内容的综合封装</h2><p>封装的逻辑基本与上述相同,进行了少量的修改.比如:</p>
<ol>
<li>SwipeRefreshLayout是在顶部或底部时捕捉下拉和上拉事件打到目的,所以在最顶部和最底部的时候拖动条目会产生冲突,为了兼容条目拖动进行了少量修改.</li>
<li>将ItemTouchHelper封装到Adapter中,将通过指定控件设置触发拖动的方法封装到ViewHolder部分.</li>
<li>对于单类型item将多type类型进行了一个简单的实现,更方便单类型item的实现等</li>
</ol>
<p>更多具体的内容有兴趣的话可以查看<a href="https://github.com/NessCurie/RecyclerViewUtils/tree/master/library/src/main/java/org/nesscurie/recyclerviewutils" target="_blank" rel="noopener">RecyclerViewUtils/library</a>中的代码.<br>使用案例可以查看:<a href="https://github.com/NessCurie/RecyclerViewUtils/tree/master/sample" target="_blank" rel="noopener">RecyclerViewUtils/sample</a>中的代码.</p>
<p>这里主要对library的用法进行说明:</p>
<h3 id="单类型item"><a href="#单类型item" class="headerlink" title="单类型item:"></a>单类型item:</h3><p>创建SimpleAdapter对象,设置给RecyclerView即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建简单的recyclerView适配器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context 上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id      item的layout的id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list    集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAdapter</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> <span class="keyword">int</span> id, List&lt;T&gt; list)</span></span></span><br></pre></td></tr></table></figure>

<p>比如: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SimpleAdapter simpleAdapter = <span class="keyword">new</span> SimpleAdapter&lt;String&gt;(<span class="keyword">this</span>, R.layout.item_simple, list) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemData</span><span class="params">(<span class="keyword">final</span> MViewHolder holder, String s, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        holder.setText(R.id.tv_center, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="多类型item"><a href="#多类型item" class="headerlink" title="多类型item"></a>多类型item</h3><h4 id="1-如果没有其他特殊需求可以直接new出BaseAdapter的对象-如果有其他需求可以继重写部分方法"><a href="#1-如果没有其他特殊需求可以直接new出BaseAdapter的对象-如果有其他需求可以继重写部分方法" class="headerlink" title="1. 如果没有其他特殊需求可以直接new出BaseAdapter的对象.如果有其他需求可以继重写部分方法."></a>1. 如果没有其他特殊需求可以直接new出BaseAdapter的对象.如果有其他需求可以继重写部分方法.</h4><p>可以重写其中的<code>onViewHolderCreated()</code>方法在创建完ViewHolder后做一些操作;<br>可以重写其中的<code>isClickEnabled()</code>设置哪些type不可点击.</p>
<h4 id="2-向adapter中添加IType的实现类"><a href="#2-向adapter中添加IType的实现类" class="headerlink" title="2. 向adapter中添加IType的实现类"></a>2. 向adapter中添加IType的实现类</h4><p>在<code>getLayoutId()</code>返回对应itemType的布局的id<br>在<code>isThisTypeItem()</code>提供判断是否是对应itemType的方法.<br>在<code>setData()</code>对item中对应id的控件设置对应数据.可以使用MViewHolder中提供的一系列方法进行链式调用</p>
<p>比如:集合中为String类型,分别有数字和其他字符类型,将数字类型显示为一种item,其他字符显示为一种item.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">adapter = <span class="keyword">new</span> BaseAdapter&lt;String&gt;(<span class="keyword">this</span>, list) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClickEnabled</span><span class="params">(<span class="keyword">int</span> viewType)</span> </span>&#123;    <span class="comment">//这里将数字type不可点击</span></span><br><span class="line">        <span class="keyword">return</span> viewType != <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">adapter.addType(<span class="keyword">new</span> IType&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.layout.item_type1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isThisTypeItem</span><span class="params">(String item, <span class="keyword">int</span> position)</span> </span>&#123;<span class="comment">//不是数字的使用该type,是灰色背景</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(item);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(MViewHolder holder, String s, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        holder.setText(R.id.tv_center, s)</span><br><span class="line">                .setDragListener(R.id.iv_hand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">adapter.addType(<span class="keyword">new</span> IType&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.layout.item_type2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isThisTypeItem</span><span class="params">(String item, <span class="keyword">int</span> position)</span> </span>&#123;  <span class="comment">//是数字的使用该type,是红色背景</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(item);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(MViewHolder holder, String s, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        holder.setText(R.id.tv_center, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="如果需要设置分割线-可以使用SimpleDecoration"><a href="#如果需要设置分割线-可以使用SimpleDecoration" class="headerlink" title="如果需要设置分割线,可以使用SimpleDecoration."></a>如果需要设置分割线,可以使用SimpleDecoration.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用系统默认分割线作为recyclerView的分割线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDecoration</span><span class="params">(Context context)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 使用指定Drawable作为recyclerView的分割线</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDecoration</span><span class="params">(Context context, Drawable drawable)</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 使用指定Drawable的id作为recyclerView的分割线</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDecoration</span><span class="params">(Context context, <span class="keyword">int</span> drawID)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="如果需要开启条目拖动和条目侧拉删除-调用adapter中的openItemTouch方法"><a href="#如果需要开启条目拖动和条目侧拉删除-调用adapter中的openItemTouch方法" class="headerlink" title="如果需要开启条目拖动和条目侧拉删除,调用adapter中的openItemTouch方法"></a>如果需要开启条目拖动和条目侧拉删除,调用adapter中的openItemTouch方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据参数开启recycler的侧拉删除和长按拖动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> recyclerView      adapter的RecyclerView的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> openLongPressDrag 是否开启长按拖动</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> openSwipeDelete   是否开启侧滑删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> refreshLayout     因为在最顶部和最底部时拖动会和下拉刷新以及加载更多冲突,所以当有</span></span><br><span class="line"><span class="comment"> *                          添加&#123;<span class="doctag">@link</span> SwipyRefreshLayout&#125;的时候需要和下拉刷新的控件关联,</span></span><br><span class="line"><span class="comment"> *                          如果没有添加下拉刷新和上拉的传null即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openItemTouch</span><span class="params">(RecyclerView recyclerView, <span class="keyword">boolean</span> openLongPressDrag,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> openSwipeDelete, SwipyRefreshLayout refreshLayout)</span></span></span><br></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simpleAdapter.openItemTouch(recyclerview, true, true, swipyrefreshlayout);</span><br></pre></td></tr></table></figure>

<h3 id="如果要设置指定控件触发条目拖动"><a href="#如果要设置指定控件触发条目拖动" class="headerlink" title="如果要设置指定控件触发条目拖动"></a>如果要设置指定控件触发条目拖动</h3><p>在<code>SimpleAdapter的setItemData()</code>方法或<code>IType实现类的setData()</code>方法中,使用holder调用<code>setDragListener(int id)</code>即可,需要adapter调用上面的<code>openItemTouch()</code>方法,否则不会生效.</p>
<p>比如:<code>holder.setDragListener(R.id.iv_hand);</code></p>
<h3 id="如果需要设置item的点击和长按事件"><a href="#如果需要设置item的点击和长按事件" class="headerlink" title="如果需要设置item的点击和长按事件"></a>如果需要设置item的点击和长按事件</h3><p>点击和长按事件封装在BaseAdapter中,如果同时设置了长按拖动和长按点击事件,会同时触发.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">adapter.setOnItemLongClickListener(<span class="keyword">this</span>);</span><br><span class="line">adapter.setOnItemClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onItemLongClick</span><span class="params">(View view, RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(View view, RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如果要添加下拉刷新或上拉加载更多"><a href="#如果要添加下拉刷新或上拉加载更多" class="headerlink" title="如果要添加下拉刷新或上拉加载更多"></a>如果要添加下拉刷新或上拉加载更多</h3><p>在布局文件中使用<code>org.nesscurie.recyclerviewutils.SwipyRefreshLayout</code>节点包裹RecyclerView,在xml中设置对应的<code>refresh_mode</code>或在代码中使用<code>setRefreshMode(int)</code>设置.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">org.nesscurie.recyclerviewutils.SwipyRefreshLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/swipyrefreshlayout"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:refresh_mode</span>=<span class="string">"both"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/recyclerview"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v7.widget.RecyclerView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">org.nesscurie.recyclerviewutils.SwipyRefreshLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用setColorSchemeResources()设置刷新控件中间的进度条的颜色,支持多个颜色,会依次出现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swipyrefreshlayout.setColorSchemeResources(android.R.color.holo_blue_bright,</span><br><span class="line">        android.R.color.holo_green_light, android.R.color.holo_orange_light,</span><br><span class="line">        android.R.color.holo_red_light);</span><br></pre></td></tr></table></figure>

<p>可以使用setProgressBackgroundColor()设置刷新控件的背景.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swipyrefreshlayout.setProgressBackgroundColor(android.R.color.darker_gray);</span><br></pre></td></tr></table></figure>

<p>设置刷新监听的回调,根据传来的参数判断是下拉刷新还是上拉加载更多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">swipyrefreshlayout.setOnRefreshListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(<span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> SwipyRefreshLayout.TOP:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SwipyRefreshLayout.BOTTOM:         </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷新完毕后调用<code>swipyrefreshlayout.setRefreshing(false);</code>隐藏刷新控件</p>
<hr>
<p>这次对RecyclerView的总结和Adapter的封装主要目的是加深对RecyclerView各需求的熟悉程度,另外锻炼一下封装的思维.RecyclerView出来的时间也挺久了,网络上对其的各种需求都有比较详细的讲解.有其他需要可以在网络上找到很多文章.</p>
</div><div class="tags"><a href="/tags/RecyclerView/">RecyclerView</a></div><div class="post-nav"><a class="pre" href="/2017/03/29/DataBinding%E6%80%BB%E7%BB%93/">DataBinding的使用和当前版本还存在的问题总结</a><a class="next" href="/2017/03/10/Markdown%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E%E5%92%8C%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/">Markdown的一些说明和常用语法</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'R2dcvRpPE66R69btJSJPByee-gzGzoHsz',
  appKey:'E9T5cJlOJ4pSgbFq1UcaPJ5y',
  placeholder:'Why so serious?',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/EditText/" style="font-size: 15px;">EditText</a> <a href="/tags/RecyclerView/" style="font-size: 15px;">RecyclerView</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/10/AboutMeInTheseFourYears/">新旅途之前的记录与总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/11/git/SVN%E8%BF%81%E7%A7%BB%E5%88%B0Git%E4%BF%9D%E7%95%99%E5%AE%8C%E6%95%B4%E7%9A%84log/">SVN迁移到Git保留完整的log</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/11/EditText%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AF%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5/">EditText 不使用系统键盘实现自定义键盘输入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/07/byte%E6%95%B0%E7%BB%84%E5%BC%8F%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/%E4%BD%BF%E7%94%A8%E6%A0%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%B9Java%E7%9A%84byte%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%BF%AB%E9%80%9F%E8%A7%A3%E6%9E%90%E5%92%8C%E6%9E%84%E5%BB%BA/">使用树结构的方式对Java的byte数组进行快速解析和构建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/28/byte%E6%95%B0%E7%BB%84%E5%BC%8F%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/%E5%B0%86Java%E7%9A%84byte%E6%95%B0%E7%BB%84%E5%88%86%E6%AE%B5%E8%A7%A3%E6%9E%90%E4%B8%BA%E6%89%80%E9%9C%80%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BBBytesReader/">将Java的byte数组分段解析为所需数据的工具类BytesReader</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/25/byte%E6%95%B0%E7%BB%84%E5%BC%8F%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/%E5%8F%82%E7%85%A7ArrayList%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%83%BD%E6%B7%BB%E5%8A%A0%E4%BB%BB%E6%84%8F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84ByteArrayList/">参照ArrayList实现一个能添加任意数据类型的ByteArrayList</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/21/byte%E6%95%B0%E7%BB%84%E5%BC%8F%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/%E5%A4%A7%E5%B0%8F%E7%AB%AFbyte%E6%95%B0%E7%BB%84%E5%92%8C%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%92%E8%BD%AC/">大小端byte数组和各种数据类型的互转</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/12/%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83Android.mk%E7%BC%96%E8%AF%91APK/">源码环境Android.mk编译APK</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/07/Kotlin%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Kotlin基础语法笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/20/Python%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/">Python的文件操作和数据库操作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://gallonyin.github.io/" title="GallonYin" target="_blank">GallonYin</a><ul></ul><a href="http://zphuanlove.github.io/" title="zhongpeihuan" target="_blank">zhongpeihuan</a><ul></ul><a href="https://blog.csdn.net/qq_33487044" title="雪松研究所" target="_blank">雪松研究所</a><ul></ul><a href="https://wkingdom.github.io/" title="WZKingdom" target="_blank">WZKingdom</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Möbius Strip World.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>